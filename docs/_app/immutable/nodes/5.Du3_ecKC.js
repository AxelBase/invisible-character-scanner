import{f as x,b as f}from"../chunks/Cvl-Y_JZ.js";import"../chunks/mY7jRIjx.js";import{a9 as e,a7 as t,Q as w,a5 as k,aa as P,ab as D,ac as r,a8 as a}from"../chunks/B11iBTST.js";import{h as A}from"../chunks/BIZYsT9B.js";import{h as E}from"../chunks/CRjuo5t4.js";import{s as d}from"../chunks/BQU-mAlj.js";import{b}from"../chunks/BprRDstm.js";const N=!0,Y=Object.freeze(Object.defineProperty({__proto__:null,prerender:N},Symbol.toStringTag,{value:"Module"}));var Z=x('<meta name="description" content="Deep dive into Unicode property regex, client-side performance, and how we detect invisible characters under 100ms even on large texts."/> <meta property="og:title" content="How Real-Time Detection Works in the Browser"/> <meta property="og:description"/> <meta property="og:url"/> <meta property="og:type" content="article"/> <meta name="twitter:card" content="summary_large_image"/>',1),H=x('<div class="container py-5 post-layout svelte-1apmzc4"><div class="breadcrumbs svelte-1apmzc4"><a class="svelte-1apmzc4">Blog</a> <span>/</span> <p>How Real-Time Detection Works</p></div> <article class="prose svelte-1apmzc4"><h1 class="svelte-1apmzc4">How Real-Time Detection Works in the Browser</h1> <p class="post-meta svelte-1apmzc4">Published: November 24, 2025</p> <p>The Invisible Character Scanner detects hidden Unicode characters instantly as you type or paste — no delay, no server round-trip. This is made possible by modern JavaScript and Unicode-aware regular expressions.</p> <h2 class="svelte-1apmzc4">The Core Technology: Unicode Property Escapes</h2> <p>We use the <code></code> syntax supported in modern browsers:</p> <pre><code><!></code></pre> <p>This single regex matches:</p> <ul><li><code></code> — All control characters</li> <li><code></code> — Format controls (including ZWJ/ZWNJ)</li> <li><code></code> — All separators except regular space</li> <li>Specific zero-width ranges (U+200B–U+FEFF)</li></ul> <h2 class="svelte-1apmzc4">Performance That Meets NFR-01</h2> <p>The SRS demands detection under 100ms for 500 KB text. We achieve this by:</p> <ul><li>Running detection only on change (Svelte reactive)</li> <li>Using a single optimized regex</li> <li>Skipping regular space U+0020 explicitly</li> <li>Capping input at 1 MB with graceful warning (NFR-05)</li></ul> <h2 class="svelte-1apmzc4">Visual Feedback You Can Trust</h2> <p>Every match is highlighted with its exact code point (e.g. <code>U+200D</code>) so you know exactly what was found and where.</p> <h2 class="svelte-1apmzc4">FAQ</h2> <details class="svelte-1apmzc4"><summary class="svelte-1apmzc4">Why not use charCodeAt() loops?</summary> <p></p></details> <details class="svelte-1apmzc4"><summary class="svelte-1apmzc4">Does it work in Safari?</summary> <p>Yes — Safari 14.1+ fully supports Unicode property escapes.</p></details> <p class="italic-note svelte-1apmzc4">Fast. Accurate. Private. That’s real-time detection done right.</p></article></div>');function K(_){var s=H();E("1apmzc4",W=>{var g=Z(),y=e(k(g),4);d(y,"content","We use modern JavaScript regex with \\p{Property_Name} syntax to detect Cc, Cf, Zs, and zero-width characters instantly — all in your browser.");var B=e(y,2);r(4),w(()=>d(B,"content",`${b??""}/blog/posts/post2`)),P(()=>{D.title="How Real-Time Detection Works in the Browser | Invisible Scanner Blog"}),f(W,g)});var o=t(s),z=t(o);r(4),a(o);var m=e(o,2),i=e(t(m),8),C=e(t(i));C.textContent="\\p{Property}",r(),a(i);var c=e(i,2),v=t(c),T=t(v);A(T,()=>"const regex = new RegExp('(\\p{Cc}|\\p{Cf}|\\p{Zs}|[\\u200B-\\u200F\\u2060-\\u2069\\uFEFF])', 'gu');"),a(v),a(c);var n=e(c,4),l=t(n),F=t(l);F.textContent="\\p{Cc}",r(),a(l);var p=e(l,2),S=t(p);S.textContent="\\p{Cf}",r(),a(p);var h=e(p,2),R=t(h);R.textContent="\\p{Zs}",r(),a(h),r(2),a(n);var u=e(n,14),U=e(t(u),2);U.textContent="Too slow and error-prone. Regex with \\p{Property} is 10–20× faster and more accurate.",a(u),r(4),a(m),a(s),w(()=>d(z,"href",`${b??""}/blog`)),f(_,s)}export{K as component,Y as universal};
